<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <head>
    <meta charset="UTF-8">
    <!-- åŸä»£ç æ›¿æ¢æˆè¿™ä¸ªï¼Œé€‚é…iPad+æ‰‹æœº+ç”µè„‘ï¼Œç¦æ­¢ç³»ç»Ÿç¼©æ”¾ï¼Œå…¨å±æ— ç™½è¾¹ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">    
    <!-- ğŸ”¤ ä¸­æ–‡SEOæ ‡ç­¾ï¼ˆä¿ç•™ï¼Œä¸å½±å“è‹±æ–‡æ”¶å½•ï¼‰ -->
    <title>è´¹çº³å¥‡é•œåŠ¨ç”»ç»˜åˆ¶å·¥å…· v12.3  - å…è´¹åœ¨çº¿åˆ¶ä½œè´¹çº³å¥‡é•œåŠ¨ç”»</title>
    <meta name="description" content="å…è´¹åœ¨çº¿è´¹çº³å¥‡é•œåŠ¨ç”»ç»˜åˆ¶å·¥å…·ï¼Œæ— éœ€å®‰è£…ï¼Œæ”¯æŒå›¾å±‚ç»˜åˆ¶ã€æ´‹è‘±çš®ã€é€å¸§æ’­æ”¾ã€æ—‹è½¬åˆ›ä½œã€å¯¼å‡ºé¡¹ç›®ï¼Œçº¯ä¸ªäººå¼€æºéç›ˆåˆ©å·¥å…·ï¼Œç¦æ­¢å•†ç”¨ç‰Ÿåˆ©ã€‚">
    <meta name="keywords" content="è´¹çº³å¥‡é•œ,è´¹é‚£å¥‡é•œ,è´¹çº³å¥‡é•œåŠ¨ç”»,è´¹é‚£å¥‡é•œåˆ¶ä½œ,åŠ¨ç”»ç»˜åˆ¶å·¥å…·,åœ¨çº¿åŠ¨ç”»åˆ›ä½œ,æ—‹è½¬åŠ¨ç”»">
    
    <!-- ğŸ”¤ è‹±æ–‡SEOæ ‡ç­¾ï¼ˆæ–°å¢ï¼Œè‹±æ–‡ç”¨æˆ·æ ¸å¿ƒï¼‰ -->
    <title>Phenakistiscope Animation Tool v12.3 - Free Online Phenakistiscope Maker</title>
    <meta name="description" content="Free online Phenakistiscope animation tool - No installation needed. Create, edit, and export phenakistiscope animations with layers, onion skin, and frame-by-frame playback. Open-source & non-commercial.">
    <meta name="keywords" content="phenakistiscope, phenakistiscope animation, online phenakistiscope tool, phenakistiscope maker, animation creator, free animation tool">
    
    <!-- ğŸš€ å¤šè¯­è¨€å£°æ˜ï¼ˆå‘Šè¯‰æœç´¢å¼•æ“æ”¯æŒä¸­è‹±æ–‡ï¼Œä¼˜å…ˆæ¨ç»™å¯¹åº”è¯­è¨€ç”¨æˆ·ï¼‰ -->
    <link rel="alternate" hreflang="zh-CN" href="https://ä½ çš„åœ°å€.pages.dev" />
    <link rel="alternate" hreflang="en" href="https://ä½ çš„åœ°å€.pages.dev" />
    <link rel="alternate" hreflang="x-default" href="https://ä½ çš„åœ°å€.pages.dev" />
    
    <!-- ğŸ“± è‹±æ–‡ç¤¾äº¤åª’ä½“åˆ†äº«ä¼˜åŒ–ï¼ˆè‹±æ–‡ç”¨æˆ·åˆ†äº«æ—¶é¢„è§ˆæ­£ç¡®ï¼‰ -->
    <meta property="og:title" content="Phenakistiscope Animation Tool v12.3 - Free Online Maker">
    <meta property="og:description" content="Create phenakistiscope animations online for free. Open-source tool with layers, onion skin, and export features.">
    <meta property="og:type" content="tool">
    <meta property="og:locale" content="en_US">
    
    <!-- å…¶ä»–åŸæœ‰æ ‡ç­¾ï¼ˆrobotsã€authorã€theme-colorç­‰ï¼Œä¿ç•™ä¸å˜ï¼‰ -->
    <meta name="robots" content="index, follow, all">
    <meta name="author" content="Elephantzoo">
    <meta name="format-detection" content="telephone=no">
    <meta name="theme-color" content="#181818">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- åŸæœ‰æ ·å¼ä»£ç ... -->

    <style>
        :root {
            --bg-color: #181818; --panel-color: #252525; --item-color: #333;
            --text-color: #e0e0e0; --accent-color: #00bcd4; --danger-color: #e74c3c;
        }
        /* æ ¸å¿ƒä¿®å¤ï¼šé˜²æ­¢æµè§ˆå™¨åŠ«æŒè§¦æ§ */
        body { font-family: 'Segoe UI', sans-serif; background-color: var(--bg-color); color: var(--text-color); margin: 0; display: flex; height: 100vh; overflow: hidden; user-select: none; touch-action: none; }
        
        /* å¼¹çª—æ ·å¼ START */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.75); z-index: 2000; display: flex; justify-content: center; align-items: center; backdrop-filter: blur(3px); animation: fadeIn 0.3s ease; }
        .modal-content { background: #252525; padding: 25px; border-radius: 8px; width: 90%; max-width: 420px; position: relative; box-shadow: 0 10px 30px rgba(0,0,0,0.6); border: 1px solid #444; color: #e0e0e0; animation: slideUp 0.3s ease; }
        .close-modal { position: absolute; top: 12px; right: 15px; background: none; border: none; color: #888; font-size: 28px; cursor: pointer; padding: 0; line-height: 1; transition: 0.2s; width: auto; text-align: right;}
        .close-modal:hover { color: #fff; transform: scale(1.1); background: none; }
        .modal-header { font-size: 18px; font-weight: bold; margin-bottom: 20px; color: var(--accent-color); border-bottom: 1px solid #333; padding-bottom: 10px; }
        .modal-body p { margin: 12px 0; font-size: 14px; line-height: 1.6; }
        .modal-body a { color: var(--accent-color); text-decoration: none; transition: 0.2s; border-bottom: 1px dashed rgba(0,188,212,0.3); }
        .modal-body a:hover { text-decoration: none; border-bottom-style: solid; color: #fff; }
        .disclaimer { color: #aaa; font-size: 13px; background: rgba(0,0,0,0.2); padding: 12px; border-radius: 4px; border-left: 3px solid var(--danger-color); margin-top: 15px; }
        .disclaimer strong { color: #ccc; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        /* å¼¹çª—æ ·å¼ END */

        .viewport { 
            flex: 1; position: relative; background-color: #111; overflow: hidden; 
            background-image: linear-gradient(45deg, #1a1a1a 25%, transparent 25%), linear-gradient(-45deg, #1a1a1a 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #1a1a1a 75%), linear-gradient(-45deg, transparent 75%, #1a1a1a 75%); 
            background-size: 20px 20px; cursor: none; min-width: 300px; touch-action: none; 
        }
        .viewport.panning { cursor: grab !important; }
        .viewport.panning:active { cursor: grabbing !important; }
        .viewport.rotating { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'><path fill='%23fff' d='M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z'/></svg>"), grab !important; }
        .viewport.erasing { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none' stroke='%23e74c3c' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2'/></svg>") 12 12, auto !important; }
        #mainCanvas { display: block; width: 100%; height: 100%; touch-action: none; }
        .save-indicator { position: absolute; top: 10px; left: 10px; z-index: 100; font-size: 12px; opacity: 0.8; pointer-events: none; display: flex; align-items: center; gap: 5px; background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 20px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; background: #555; }
        .dot.unsaved { background: var(--danger-color); box-shadow: 0 0 5px var(--danger-color); }
        .dot.saved { background: var(--accent-color); }
        .sidebar { width: 340px; background-color: var(--panel-color); border-left: 1px solid #333; display: flex; flex-direction: column; z-index: 10; box-shadow: -4px 0 10px rgba(0,0,0,0.3); cursor: default; }
        .scroll-area { flex: 1; overflow-y: auto; padding: 15px; }
        .scroll-area::-webkit-scrollbar { width: 5px; background: #222; }
        .scroll-area::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }
        .panel-section { margin-bottom: 20px; background: var(--item-color); padding: 10px; border-radius: 6px; }
        .section-header { font-size: 11px; font-weight: bold; text-transform: uppercase; color: #888; border-bottom: 1px solid #444; padding-bottom: 5px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
        .row { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
        .btn-group { display: flex; width: 100%; gap: 1px; background: #222; border-radius: 4px; overflow: hidden; }
        .btn-group-full { display:flex; flex-wrap: wrap; gap:5px; margin-top:8px;}
        button, .btn-label { background-color: #444; color: #ddd; border: none; padding: 6px 10px; cursor: pointer; flex: 1; font-size: 12px; transition: 0.1s; text-align: center; display: inline-block; line-height: normal; border-radius: 3px; }
        button:hover, .btn-label:hover { background-color: #555; }
        button:disabled { background-color: #333; color: #777; cursor: not-allowed; }
        button.active, .btn-label.active { background-color: var(--accent-color); color: #000; font-weight: bold; }
        button.small-btn { padding: 4px 8px; flex: 0 0 auto; }
        button.dir-btn.active { background: var(--danger-color); color:#fff; }
        .btn-label.json-btn { background: #9b59b6; color:#fff; } .btn-label.json-btn:hover { background: #8e44ad; }
        button.json-btn { background: #9b59b6; color:#fff; } button.json-btn:hover { background: #8e44ad; }
        button.reset-btn { background: #e74c3c; color:#fff; } button.reset-btn:hover { background: #c0392b; }
        input[type="range"] { flex: 1; height: 4px; accent-color: var(--accent-color); background: #555; border-radius: 2px; -webkit-appearance: none; appearance: none; padding:0; margin:0;}
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 12px; height: 12px; border-radius: 50%; background: var(--accent-color); cursor: pointer; }
        input[type="range"]::-moz-range-thumb { width: 12px; height: 12px; border-radius: 50%; background: var(--accent-color); cursor: pointer; border:none; }
        input[type="number"] { width: 40px; background: #222; border: 1px solid #444; color: white; border-radius: 3px; padding: 3px; text-align: center; }
        input[type="file"], input[type="checkbox"].visually-hidden { opacity:0; width:0; height:0; position:absolute; }
        .layer-list { display: flex; flex-direction: column; gap: 4px; max-height: 180px; overflow-y: auto; background: #222; border-radius: 4px; padding: 4px; }
        .layer-item { display: flex; align-items: center; gap: 8px; padding: 6px; background: #333; color: #aaa; cursor: grab; border: 1px solid transparent; border-radius: 3px; transition: background-color 0.1s; }
        .layer-item.active { background: #444; color: #fff; border-color: var(--accent-color); }
        .layer-item.drag-over { background-color: var(--accent-color); opacity: 0.5; }
        .layer-item.dragging { opacity: 0.4; }
        .layer-vis { cursor: pointer; width: 20px; text-align: center; }
        .layer-name { flex: 1; font-size: 12px; user-select: none; }
        .current-layer-input { flex:1; background:#333; border:1px solid #555; color:#fff; font-size:12px; padding:2px 4px; border-radius:2px; outline:none; text-align: left; min-width: 100px; }
        .color-input-wrapper { width: 24px; height: 24px; border: none; background: none; padding: 0; cursor: pointer; border-radius: 4px; overflow: hidden; }
        input[type="color"] { -webkit-appearance: none; -moz-appearance: none; appearance: none; width: 32px; height: 32px; background-color: transparent; border: none; cursor: pointer; position: relative; top: -4px; left: -4px; }
        input[type="color"]::-webkit-color-swatch { border-radius: 4px; border: 2px solid #555; }
        input[type="color"]::-moz-color-swatch { border-radius: 4px; border: 2px solid #555; }
        .shortcut-panel { position: absolute; bottom: 10px; left: 10px; right: 10px; background: rgba(0,0,0,0.9); padding: 8px 15px; border-radius: 6px; font-size: 12px; color: #ccc; pointer-events: none; border: 1px solid #555; z-index: 99; display: flex; flex-wrap: wrap; gap: 18px; justify-content: center; }
        .shortcut-panel span { display: inline-block; }
        .shortcut-panel strong { color: var(--accent-color); font-weight: normal; padding: 0 2px; }
        /* ====== iPadè§¦æ‘¸ä¸“å±ä¼˜åŒ– (æ–°å¢) ====== */
        * {
        -webkit-touch-callout: none; /* ç¦ç”¨iPadé•¿æŒ‰å¼¹å‡ºèœå• */
        -webkit-user-select: none;   /* ç¦ç”¨iPadé•¿æŒ‰é€‰ä¸­æ–‡æœ¬ */
        user-select: none;
        touch-action: none;          /* ç¦æ­¢ç³»ç»Ÿé»˜è®¤çš„è§¦æ‘¸æ»šåŠ¨/ç¼©æ”¾ï¼Œå®Œå…¨è‡ªå®šä¹‰æ‰‹åŠ¿ */
        }
        canvas {
        -webkit-tap-highlight-color: transparent; /* ç§»é™¤iPadç‚¹å‡»ç”»å¸ƒçš„é«˜äº®æ¡† */
        tap-highlight-color: transparent;
        }
        /* è§£å†³iPadç«¯æŒ‰é’®ç‚¹å‡»å»¶è¿Ÿ */
        button {
        -webkit-touch-callout: none;
        touch-action: manipulation;
        }
    </style>
</head>
<body>
    <!-- å¯åŠ¨å¼¹çª—ï¼ˆæ–°å¢è‹±æ–‡ç¿»è¯‘ï¼Œä¸å½±å“ä¸­æ–‡é˜…è¯»ï¼‰ -->
    <div id="welcomeModal" class="modal-overlay">
        <div class="modal-content">
            <button class="close-modal" id="closeModalBtn">Ã—</button>
            <div class="modal-header">å…³äºæœ¬é¡¹ç›® / About This Project</div>
            <div class="modal-body">
                <p>â–¸ å¼€å‘è€… / Developerï¼šElephantzoo</p>
                <p>â–¸ é¡¹ç›®å¼€æº / Open Sourceï¼š<a href="https://github.com/ElephantZoo/-" target="_blank">GitHub Repository</a></p>
                <p>â–¸ äº¤æµåé¦ˆ / Feedbackï¼š<a href="https://www.xiaohongshu.com/user/profile/6103db4f00000000010074ba" target="_blank">å°çº¢ä¹¦@åŠæ‰‡ğŸ˜</a> (UID: 49697709596)</p>
                
                <div class="disclaimer">
                    æœ¬ç½‘ç«™ä¸ºä¸ªäººéç›ˆåˆ©å¼€æºé¡¹ç›® / This is a personal open-source non-commercial project.<br>
                    âœ… <strong>å…¨ç«™åŠŸèƒ½ / åˆ›ä½œå†…å®¹ å…è´¹ä½¿ç”¨</strong> / All features & creations are free for personal use.<br>
                    âŒ <strong>ä¸¥ç¦ä»»ä½•å•†ç”¨ã€ç›ˆåˆ©ã€å€’å–ç­‰å•†ä¸šç‰Ÿåˆ©è¡Œä¸º</strong> / Commercial use, profit-making, or resale is strictly prohibited.<br>
                    <div style="margin-top:8px; font-style: italic;">æ„Ÿè°¢ä½¿ç”¨ / Thank you for using âœ¨</div>
                </div>
            </div>
        </div>
    </div>

    <div class="viewport" id="viewport">
        <div class="save-indicator"> <div class="dot saved" id="statusDot"></div> <span id="statusText">å·²ä¿å­˜</span> </div>
        <canvas id="mainCanvas"></canvas>
        <div class="shortcut-panel">
            <span><strong>ç©ºæ ¼</strong> æ‹–æ‹½ | <strong>R</strong> æ—‹è½¬ | <strong>B</strong> ç”»ç¬” | <strong>E</strong> æ©¡çš®æ“¦</span>
            <span><strong>æ»šè½®</strong> ç¼©æ”¾ | <strong>Shift+æ»šè½®</strong> æ—‹è½¬</span>
            <span><strong>â† â†’</strong> å¾®è°ƒæ—‹è½¬ | <strong>[ ]</strong> ç”»ç¬”ç²—ç»†</span>
            <span><strong>Ctrl+Z</strong> æ’¤é”€ | <strong>Ctrl+Y</strong> é‡åš | <strong>Ctrl+0</strong> å¤ä½è§†å›¾</span>
        </div>
    </div>
    <div class="sidebar">
        <div class="scroll-area">
            <div class="panel-section">
                <div class="section-header">å…¨å±€æ§åˆ¶</div>
                <div class="row" style="margin-bottom:8px;">
                    <span style="font-size:12px; flex-shrink: 0;">é¡¹ç›®åç§°:</span>
                    <input type="text" id="projectNameInput" class="current-layer-input" style="flex-grow:1;" placeholder="ä¸ºä½ çš„é¡¹ç›®å‘½å">
                </div>
                <div class="btn-group" style="margin-bottom:8px;"> <button id="undoBtn">â†© æ’¤é”€</button> <button id="redoBtn">â†ª é‡åš</button> </div>
                <div class="btn-group" style="margin-bottom:8px;">
                    <button id="playbackModeBtn">é€æ ¼æ¨¡å¼</button> <button id="playBtn">â–¶ æ’­æ”¾</button>
                </div>
                <div class="row">
                    <span style="font-size:12px">é€Ÿåº¦:</span> <input type="range" id="fpsRange" min="1" max="60" value="12">
                    <span id="fpsVal" style="font-size:11px; width:20px;">12</span>
                    <button id="rotateDirBtn" class="dir-btn" title="åˆ‡æ¢æ—‹è½¬æ–¹å‘">â†º åå‘</button>
                </div>
            </div>
            <div class="panel-section">
                <div class="section-header">
                    <input type="text" id="currentLayerInput" class="current-layer-input" placeholder="å½“å‰å›¾å±‚">
                    <div>
                        <button class="small-btn" id="addLayerBtn" title="æ–°å»ºå›¾å±‚">+</button>
                        <button class="small-btn" id="delLayerBtn" title="åˆ é™¤å›¾å±‚">-</button>
                        <button class="small-btn" id="copyLayerBtn" title="å¤åˆ¶å›¾å±‚">â§‰</button>
                        <button class="small-btn" id="clearLayerBtn" title="æ¸…ç©ºå›¾å±‚">ğŸ—‘ï¸</button>
                    </div>
                </div>
                <div class="row">
                    <div class="color-input-wrapper" title="ä¿®æ”¹å›¾å±‚é¢œè‰²"><input type="color" id="layerColorInput"></div>
                    <div class="btn-group">
                        <button id="modeFillBtn" title="å¡«å……æ¨¡å¼ (B)">å¡«å……</button> <button id="modeStrokeBtn" title="è·¯å¾„æ¨¡å¼ (B)">è·¯å¾„</button> <button id="toolEraserBtn" title="æ©¡çš®æ“¦ (E)">æ“¦é™¤</button>
                    </div>
                </div>
                <div class="row">
                    <span style="font-size:12px; flex-shrink: 0;">é€æ˜åº¦:</span>
                    <input type="range" id="layerOpacity" min="0" max="1" step="0.05" value="1">
                    <span id="layerOpacityVal" style="font-size:11px; width:28px;">1.0</span>
                </div>
                <div class="layer-list" id="layerList"></div>
            </div>
            <div class="panel-section">
                <div class="section-header">ç”»ç¬”</div>
                <div class="row">
                    <span style="font-size:12px" id="brushSizeLabel">ç²—ç»†:</span>
                    <input type="range" id="brushSize" min="1" max="100" value="10">
                    <span id="brushSizeVal" style="font-size:11px; width:20px;">10</span>
                </div>
            </div>
            <div class="panel-section">
                <div class="section-header">è§†å›¾ (View)</div>
                <div class="row"> <button id="resetViewBtn">å¤ä½è§†å›¾</button> </div>
                <div class="row" style="justify-content: space-between;">
                    <label for="snapToggle" style="font-size:12px; cursor:pointer;">ä¸­çº¿å¸é™„</label> <input type="checkbox" id="snapToggle" checked>
                </div>
                <div class="row">
                    <label for="backgroundColorInput" style="font-size:12px; cursor:pointer;">ç”»å¸ƒé¢œè‰²</label>
                    <div class="color-input-wrapper" title="ä¿®æ”¹ç”»å¸ƒèƒŒæ™¯é¢œè‰²"><input type="color" id="backgroundColorInput"></div>
                </div>
                <div class="row">
                    <span style="font-size:12px">æ—‹è½¬</span> <input type="range" id="rotationSlider" min="0" max="360" value="0">
                </div>
            </div>
            <div class="panel-section">
                <div class="section-header">è¾…åŠ©ä¸å®Œæ•´å¯¼å‡º</div>
                <div class="row" style="align-items: center;">
                    <label for="onionToggle" style="font-size:12px; cursor:pointer; flex-shrink: 0;">æ´‹è‘±çš®</label>
                    <input type="checkbox" id="onionToggle" checked>
                    <div style="display: flex; gap: 5px; margin-left: auto;">
                        <label for="onionBeforeToggle" class="btn-label small-btn" style="padding: 2px 6px; flex:none;">å‰ä¸€å¸§</label>
                        <input type="checkbox" id="onionBeforeToggle" class="visually-hidden" checked>
                        <label for="onionAfterToggle" class="btn-label small-btn" style="padding: 2px 6px; flex:none;">åä¸€å¸§</label>
                        <input type="checkbox" id="onionAfterToggle" class="visually-hidden" checked>
                    </div>
                </div>
                <div class="row">
                    <span style="font-size:12px; flex-shrink: 0;">æ´‹è‘±çš®é€æ˜åº¦:</span>
                    <input type="range" id="onionOpacity" min="0" max="1" step="0.05" value="0.5">
                    <span id="onionOpacityVal" style="font-size:11px; width:28px;">0.5</span>
                </div>
                <div class="row">
                    <button id="onionLayerBtn" class="small-btn" title="åˆ‡æ¢æ´‹è‘±çš®æ˜¾ç¤ºåœ¨ç”»é¢æœ€ä¸Šå±‚/æœ€ä¸‹å±‚">æ´‹è‘±çš® â–² ç½®é¡¶</button>
                </div>
                <div class="row"> <span style="font-size:12px">æ‰‡å½¢æ•°</span> <input type="number" id="sliceCount" value="12" min="4" max="24"> </div>
                <div class="btn-group-full">
                    <button id="exportJsonBtn" class="json-btn">å¯¼å‡ºé¡¹ç›®(ZIP)</button>
                </div>
                <div class="btn-group-full">
                    <label for="importJsonInput" class="btn-label json-btn" style="flex-grow: 2;">å¯¼å…¥é¡¹ç›® (JSON/ZIP)</label>
                    <input type="file" id="importJsonInput" accept=".json,.zip"> <button id="resetAllBtn" class="reset-btn">é‡ç½®æ‰€æœ‰</button>
                </div>
            </div>
        </div>
    </div>

<script>
    const CONFIG = { baseSize: 500, maxHistory: 50, pathSimplificationThreshold: 1.5 };

    class Path { constructor(points) { this.id = Date.now() + Math.random(); this.points = points; } }
    class Layer {
        constructor(id, name, color) {
            this.id = id; this.name = name; this.visible = true; this.paths = [];
            this.mode = 'stroke'; this.color = color || `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`;
            this.strokeWidth = 10; this.opacity = 1;
        }
    }

    const state = {
        projectName: 'æœªå‘½åé¡¹ç›®',
        layers: [], activeLayerIndex: -1, isPlaying: false, sliceCount: 12, animRotation: 0, rotDirection: 1, playbackMode: 'slice',
        backgroundColor: '#ffffff', zoom: 1, panX: 0, panY: 0, viewRotation: 0, isDrawing: false, isPanning: false, isRotating: false, isErasing: false,
        currentTool: 'brush', currentBrushPath: [], pathsToErase: new Set(),
        drag: { isActive: false, startX: 0, startY: 0, startPanX: 0, startPanY: 0 },
        draggedLayerId: null,
        dragStartAngle: 0, dragStartViewRot: 0, cursorWorldX: 0, cursorWorldY: 0, cursorScreenX: 0, cursorScreenY: 0, isCursorInCanvas: false,
        onionSkins: { enabled: true, showBefore: true, showAfter: true, opacity: 0.5 },
        onionOnTop: true,
        snapToMidline: true, hasUnsavedChanges: false, dpr: 1, fps: 12
    };

    const DOM = {};
    let undoStack = [], redoStack = [];

    function init() {
        const ids = [ "viewport", "mainCanvas", "importJsonInput", "onionToggle", "onionOpacity", "onionOpacityVal", "fpsRange", "fpsVal", "rotationSlider", "currentLayerInput", "layerList", "brushSizeLabel", "brushSize", "brushSizeVal", "statusDot", "statusText", "playBtn", "playbackModeBtn", "sliceCount", "snapToggle", "layerColorInput", "layerOpacity", "layerOpacityVal", "modeFillBtn", "modeStrokeBtn", "toolEraserBtn", "undoBtn", "redoBtn", "addLayerBtn", "delLayerBtn", "clearLayerBtn", "resetViewBtn", "exportJsonBtn", "resetAllBtn", "rotateDirBtn", "backgroundColorInput", "onionLayerBtn", "projectNameInput", "copyLayerBtn", "onionBeforeToggle", "onionAfterToggle", "welcomeModal", "closeModalBtn" ];
        ids.forEach(id => DOM[id] = document.getElementById(id));
        DOM.ctx = DOM.mainCanvas.getContext('2d');
        state.dpr = window.devicePixelRatio || 1;
        resizeCanvas(); centerView(); addLayer("å›¾å±‚ 1");
        new ResizeObserver(() => { resizeCanvas(); render(); }).observe(DOM.viewport);
        bindEvents(); updateUI(); saveHistory(); requestAnimationFrame(loop);
    }

    function render() {
        if (!DOM.mainCanvas.width || !DOM.mainCanvas.height) return;
        const ctx = DOM.ctx;
        ctx.save();
        ctx.clearRect(0, 0, DOM.mainCanvas.width, DOM.mainCanvas.height);
        ctx.scale(state.dpr, state.dpr);
        
        ctx.save();
        setupTransform(ctx);
        const radius = CONFIG.baseSize / 2 - 2;
        ctx.beginPath();
        ctx.arc(CONFIG.baseSize / 2, CONFIG.baseSize / 2, radius, 0, Math.PI * 2);
        ctx.fillStyle = state.backgroundColor; ctx.fill();
        ctx.clip();
        
        const activeLayer = getActiveLayer();
        if (state.onionSkins.enabled && !state.isPlaying && activeLayer && !state.onionOnTop) {
            renderOnionSkins(ctx);
        }
        
        state.layers.forEach(layer => { if (layer.visible) renderLayer(ctx, layer); });
        
        if (state.isDrawing && state.currentBrushPath.length > 0) renderLayer(ctx, { ...getActiveLayer(), paths: [new Path(state.currentBrushPath)] });
        
        if (state.onionSkins.enabled && !state.isPlaying && activeLayer && state.onionOnTop) {
            renderOnionSkins(ctx);
        }
        ctx.restore();
        
        if (!state.isPlaying) {
            ctx.save(); setupTransform(ctx); drawGrid(ctx); ctx.restore();
        }
        
        if (state.isCursorInCanvas && !state.isPanning && !state.isRotating) {
            const activeLayer = getActiveLayer();
            if (activeLayer) {
                ctx.save();
                ctx.lineWidth = 1;
                ctx.strokeStyle = state.currentTool === 'eraser' ? 'rgba(231, 76, 60, 0.9)' : 'rgba(100,100,100,0.8)';
                const showCrosshair = state.currentTool === 'eraser' || (state.currentTool === 'brush' && activeLayer.mode === 'fill');
                
                if (showCrosshair) {
                    const crosshairSize = 10;
                    ctx.beginPath();
                    ctx.moveTo(state.cursorScreenX - crosshairSize, state.cursorScreenY);
                    ctx.lineTo(state.cursorScreenX + crosshairSize, state.cursorScreenY);
                    ctx.moveTo(state.cursorScreenX, state.cursorScreenY - crosshairSize);
                    ctx.lineTo(state.cursorScreenX, state.cursorScreenY + crosshairSize);
                    ctx.stroke();
                } else {
                    const cursorRadius = (activeLayer.strokeWidth / 2) * state.zoom;
                    ctx.beginPath();
                    ctx.arc(state.cursorScreenX, state.cursorScreenY, cursorRadius, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                ctx.restore();
            }
        }
        ctx.restore();
    }
    
    function setupTransform(ctx) { ctx.translate(state.panX, state.panY); ctx.scale(state.zoom, state.zoom); const cx = CONFIG.baseSize / 2, cy = CONFIG.baseSize / 2; ctx.translate(cx, cy); ctx.rotate(state.viewRotation * Math.PI / 180); if (state.isPlaying) ctx.rotate(state.animRotation * Math.PI / 180); ctx.translate(-cx, -cy); }
    
    function renderLayer(ctx, layer) {
        ctx.save();
        ctx.globalAlpha = layer.opacity;
        ctx.strokeStyle = layer.color;
        ctx.fillStyle = layer.color;
        ctx.lineWidth = layer.strokeWidth;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        layer.paths.forEach(path => {
            if (state.isErasing && state.pathsToErase.has(path.id)) return;
            if (path.points.length < 1) return;
            ctx.beginPath();
            ctx.moveTo(path.points[0].x, path.points[0].y);
            for (let i = 1; i < path.points.length; i++) ctx.lineTo(path.points[i].x, path.points[i].y);
            if (layer.mode === 'fill') { if (path.points.length > 1) ctx.closePath(); ctx.fill(); } else { ctx.stroke(); }
        });
        ctx.restore();
    }

    function renderOnionSkins(ctx) {
        const activeLayer = getActiveLayer(); if (!activeLayer || activeLayer.paths.length === 0) return;
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = CONFIG.baseSize; tempCanvas.height = CONFIG.baseSize;
        const tempCtx = tempCanvas.getContext('2d');
        renderLayer(tempCtx, { ...activeLayer, opacity: 1 });

        const step = 360 / state.sliceCount * Math.PI / 180;
        const drawTintedFrame = (rotation, color) => {
            const tintedCanvas = document.createElement('canvas');
            tintedCanvas.width = CONFIG.baseSize; tintedCanvas.height = CONFIG.baseSize;
            const tintedCtx = tintedCanvas.getContext('2d');
            tintedCtx.drawImage(tempCanvas, 0, 0);
            tintedCtx.globalCompositeOperation = 'source-in';
            tintedCtx.fillStyle = color;
            tintedCtx.fillRect(0, 0, CONFIG.baseSize, CONFIG.baseSize);

            ctx.save();
            ctx.globalAlpha = state.onionSkins.opacity;
            ctx.translate(CONFIG.baseSize/2, CONFIG.baseSize/2);
            ctx.rotate(rotation);
            ctx.translate(-CONFIG.baseSize/2, -CONFIG.baseSize/2);
            ctx.drawImage(tintedCanvas, 0, 0);
            ctx.restore();
        };
        if (state.onionSkins.showBefore) drawTintedFrame(-step * state.rotDirection, 'rgba(255, 0, 0, 0.7)');
        if (state.onionSkins.showAfter) drawTintedFrame(step * state.rotDirection, 'rgba(0, 0, 255, 0.7)');
    }

    function updateUI() {
        DOM.projectNameInput.value = state.projectName;
        const activeLayer = getActiveLayer(); const hasLayers = activeLayer !== null;
        DOM.currentLayerInput.disabled = !hasLayers; DOM.layerColorInput.disabled = !hasLayers;
        DOM.modeFillBtn.disabled = !hasLayers; DOM.modeStrokeBtn.disabled = !hasLayers;
        DOM.toolEraserBtn.disabled = !hasLayers; DOM.brushSize.disabled = !hasLayers;
        DOM.layerOpacity.disabled = !hasLayers; DOM.delLayerBtn.disabled = state.layers.length <= 1;
        if (hasLayers) {
            DOM.currentLayerInput.value = activeLayer.name; DOM.layerColorInput.value = activeLayer.color;
            DOM.modeFillBtn.classList.toggle('active', state.currentTool === 'brush' && activeLayer.mode === 'fill');
            DOM.modeStrokeBtn.classList.toggle('active', state.currentTool === 'brush' && activeLayer.mode === 'stroke');
            DOM.toolEraserBtn.classList.toggle('active', state.currentTool === 'eraser');
            DOM.brushSize.value = activeLayer.strokeWidth; DOM.brushSizeVal.textContent = activeLayer.strokeWidth;
            DOM.layerOpacity.value = activeLayer.opacity; DOM.layerOpacityVal.textContent = activeLayer.opacity.toFixed(2);
        } else { DOM.currentLayerInput.value = "æ— å›¾å±‚"; }
        DOM.undoBtn.disabled = undoStack.length <= 1; DOM.redoBtn.disabled = redoStack.length === 0;
        DOM.backgroundColorInput.value = state.backgroundColor;
        DOM.onionLayerBtn.textContent = state.onionOnTop ? 'æ´‹è‘±çš® â–² ç½®é¡¶' : 'æ´‹è‘±çš® â–¼ ç½®åº•';
        DOM.onionLayerBtn.classList.toggle('active', state.onionOnTop);
        DOM.onionToggle.checked = state.onionSkins.enabled;
        DOM.onionBeforeToggle.checked = state.onionSkins.showBefore;
        DOM.onionAfterToggle.checked = state.onionSkins.showAfter;
        document.querySelector('label[for="onionBeforeToggle"]').classList.toggle('active', state.onionSkins.showBefore && state.onionSkins.enabled);
        document.querySelector('label[for="onionAfterToggle"]').classList.toggle('active', state.onionSkins.showAfter && state.onionSkins.enabled);
        DOM.onionOpacityVal.textContent = state.onionSkins.opacity.toFixed(2);
        DOM.onionOpacity.value = state.onionSkins.opacity;
        renderLayerList();
    }
    
    function renderLayerList() {
        DOM.layerList.innerHTML = '';
        state.layers.forEach(layer => {
            const div = document.createElement('div');
            div.className = `layer-item ${layer.id === getActiveLayer()?.id ? 'active' : ''}`;
            div.dataset.layerId = layer.id;
            div.draggable = true;
            const vis = document.createElement('span'); vis.className = 'layer-vis';
            vis.innerHTML = layer.visible ? 'ğŸ‘ï¸' : 'ğŸš«';
            vis.onclick = (e) => { e.stopPropagation(); toggleLayerVisibility(layer.id); };
            const nameBox = document.createElement('span'); nameBox.className = 'layer-name'; nameBox.innerText = layer.name;
            const colorIndicator = document.createElement('div');
            colorIndicator.style.cssText = `width:12px; height:12px; background-color:${layer.color}; border-radius:3px; border:1px solid #222; flex-shrink:0; opacity:${layer.opacity};`;
            div.appendChild(vis); div.appendChild(colorIndicator); div.appendChild(nameBox);
            div.onclick = () => setActiveLayer(state.layers.findIndex(l => l.id === layer.id));
            div.addEventListener('dragstart', handleDragStart);
            div.addEventListener('dragover', handleDragOver);
            div.addEventListener('dragleave', e => e.currentTarget.classList.remove('drag-over'));
            div.addEventListener('drop', handleDrop);
            div.addEventListener('dragend', handleDragEnd);
            DOM.layerList.prepend(div);
        });
    }

    function getActiveLayer() { return state.activeLayerIndex > -1 ? state.layers[state.activeLayerIndex] : null; }
    function addLayer(name, color) { const newLayer = new Layer(Date.now(), name || `å›¾å±‚ ${state.layers.length + 1}`, color); state.layers.push(newLayer); setActiveLayer(state.layers.length - 1); saveHistory(); }
    function deleteLayer() { if (state.layers.length <= 1) return; state.layers.splice(state.activeLayerIndex, 1); setActiveLayer(Math.max(0, state.activeLayerIndex - 1)); saveHistory(); }
    function clearLayer() { const layer = getActiveLayer(); if(layer && confirm(`ç¡®å®šè¦æ¸…ç©ºå›¾å±‚ "${layer.name}" å—?`)) { layer.paths = []; saveHistory(); render(); } }
    function duplicateLayer() {
        const activeLayer = getActiveLayer(); if (!activeLayer) return;
        const newLayer = JSON.parse(JSON.stringify(activeLayer));
        newLayer.id = Date.now();
        newLayer.name = `${activeLayer.name} (å‰¯æœ¬)`;
        state.layers.splice(state.activeLayerIndex + 1, 0, newLayer);
        setActiveLayer(state.activeLayerIndex + 1);
        saveHistory();
    }
    function setActiveLayer(index) { state.activeLayerIndex = index; updateUI(); render(); }
    function toggleLayerVisibility(layerId) { const layer = state.layers.find(l => l.id === layerId); if(layer) { layer.visible = !layer.visible; saveHistory(); updateUI(); render(); } }
    function changeActiveLayerProperty(prop, value) { const layer = getActiveLayer(); if (layer && layer[prop] !== value) { layer[prop] = value; saveHistory(); updateUI(); render(); } }
    function simplifyPath(points, threshold) { if (points.length < 3) return points; const newPoints = [points[0]]; let lastPoint = points[0]; for (let i = 1; i < points.length -1; i++) { const dist = Math.hypot(points[i].x - lastPoint.x, points[i].y - lastPoint.y); if (dist > threshold) { newPoints.push(points[i]); lastPoint = points[i]; } } newPoints.push(points[points.length - 1]); if(newPoints.length === 1 && points.length > 1) newPoints.push(points[1]); return newPoints; }
    function findClosestPath(pos) { const layer = getActiveLayer(); if (!layer) return null; let closestPath = null, minDistance = Infinity; for (const path of layer.paths) { if(state.pathsToErase.has(path.id)) continue; for (const point of path.points) { const dist = Math.hypot(pos.x - point.x, pos.y - point.y); if (dist < minDistance) { minDistance = dist; closestPath = path; } } } return (minDistance < (layer.strokeWidth/2 + 5) / state.zoom) ? closestPath : null; }
    function saveHistory() { const snapshot = JSON.stringify({ layers: state.layers, activeLayerIndex: state.activeLayerIndex }); undoStack.push(snapshot); if (undoStack.length > CONFIG.maxHistory) undoStack.shift(); redoStack = []; if (undoStack.length > 1) { setUnsaved(true); } updateUI(); }
    function loadHistory(snapshot) { const data = JSON.parse(snapshot); state.layers = data.layers; state.activeLayerIndex = data.activeLayerIndex; updateUI(); render(); }
    function undo() { if (undoStack.length <= 1) return; redoStack.push(undoStack.pop()); loadHistory(undoStack[undoStack.length-1]); }
    function redo() { if (redoStack.length === 0) return; const stateToLoad = redoStack.pop(); undoStack.push(stateToLoad); loadHistory(stateToLoad); }
    function setUnsaved(val) { state.hasUnsavedChanges = val; DOM.statusDot.className = `dot ${val ? 'unsaved' : 'saved'}`; DOM.statusText.innerText = val ? 'æœªä¿å­˜' : 'å·²ä¿å­˜'; }
    function handleDragStart(e) { e.currentTarget.classList.add('dragging'); state.draggedLayerId = parseFloat(e.currentTarget.dataset.layerId); e.dataTransfer.effectAllowed = 'move'; }
    function handleDragOver(e) { e.preventDefault(); const target = e.currentTarget; if (parseFloat(target.dataset.layerId) !== state.draggedLayerId) { target.classList.add('drag-over'); } }
    function handleDrop(e) { e.preventDefault(); const target = e.currentTarget; target.classList.remove('drag-over'); const activeId = getActiveLayer()?.id; const droppedOnId = parseFloat(target.dataset.layerId); const draggedIndex = state.layers.findIndex(l => l.id === state.draggedLayerId); const targetIndex = state.layers.findIndex(l => l.id === droppedOnId); if(draggedIndex === -1 || targetIndex === -1) return; const [draggedLayer] = state.layers.splice(draggedIndex, 1); state.layers.splice(targetIndex, 0, draggedLayer); state.activeLayerIndex = activeId ? state.layers.findIndex(l => l.id === activeId) : 0; saveHistory(); renderLayerList(); }
    function handleDragEnd(e) { e.currentTarget.classList.remove('dragging'); document.querySelectorAll('.layer-item').forEach(el => el.classList.remove('drag-over')); }
    function resetInteractionState() { if (!state.isPanning) { state.isRotating = false; state.isDrawing = false; state.isErasing = false; state.drag.isActive = false; state.currentBrushPath = []; state.pathsToErase.clear(); DOM.viewport.classList.remove('rotating'); } }

    function dataURLtoBlob(dataurl) { const arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]); let n = bstr.length; const u8arr = new Uint8Array(n); while(n--){ u8arr[n] = bstr.charCodeAt(n); } return new Blob([u8arr], {type:mime}); }
    function triggerDownload(blob, filename) { const a = document.createElement('a'); const url = URL.createObjectURL(blob); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); setTimeout(() => { document.body.removeChild(a); window.URL.revokeObjectURL(url); }, 0); }
    function loadProjectData(jsonString, filename) {
        try {
            const data = JSON.parse(jsonString);
            if (!data.state) throw new Error("JSON æ–‡ä»¶ç¼ºå°‘ 'state' å­—æ®µã€‚");
            let finalProjectName = 'å¯¼å…¥çš„é¡¹ç›®';
            if (filename) finalProjectName = filename.replace(/\.(json|zip)$/i, '');
            if (data.state.projectName) finalProjectName = data.state.projectName;
            if (data.state.onionEnabled !== undefined) { data.state.onionSkins = { enabled: data.state.onionEnabled, opacity: data.state.onionOpacity || 0.5, showBefore: true, showAfter: true }; delete data.state.onionEnabled; delete data.state.onionOpacity; }
            const persistentState = { projectName: finalProjectName, layers: data.state.layers, activeLayerIndex: data.state.activeLayerIndex, sliceCount: data.state.sliceCount, rotDirection: data.state.rotDirection, backgroundColor: data.state.backgroundColor || '#ffffff', zoom: data.state.zoom, panX: data.state.panX, panY: data.state.panY, viewRotation: data.state.viewRotation, onionSkins: data.state.onionSkins, onionOnTop: data.state.onionOnTop || true, snapToMidline: data.state.snapToMidline, fps: data.state.fps, playbackMode: data.state.playbackMode || 'slice' };
            Object.assign(state, persistentState);
            resetInteractionState(); setActiveLayer(state.activeLayerIndex);
            undoStack = []; redoStack = []; saveHistory(); setUnsaved(false);
            updateUI(); render();
        } catch (err) { alert('å¯¼å…¥å¤±è´¥: æ— æ•ˆçš„æ–‡ä»¶æ ¼å¼æˆ–å†…å®¹ã€‚\n' + err.message); console.error(err); }
    }

    function bindEvents() {
        DOM.viewport.addEventListener('pointerdown', e => { 
            if (!e.isPrimary && e.pointerType !== 'pen') return;
            e.preventDefault();

            DOM.viewport.setPointerCapture(e.pointerId); 
            state.isCursorInCanvas = true; 
            
            if (e.button === 1 || state.isPanning) { startDrag(e); return; } 
            
            if (state.isRotating) { 
                state.dragStartAngle = getMouseAngle(e.clientX, e.clientY); 
                state.dragStartViewRot = state.viewRotation; 
                return; 
            } 
            
            const pos = getScreenToWorldPos(e.clientX, e.clientY); 
            if (state.currentTool === 'eraser') { 
                state.isErasing = true; 
                const pathToErase = findClosestPath(pos); 
                if (pathToErase) state.pathsToErase.add(pathToErase.id); 
            } else if (state.currentTool === 'brush') { 
                state.isDrawing = true; 
                state.currentBrushPath = [pos]; 
            } 
        });

        DOM.viewport.addEventListener('pointermove', e => { 
            if (!e.isPrimary && e.pointerType !== 'pen') return;
            e.preventDefault();

            state.cursorScreenX = e.clientX - DOM.viewport.getBoundingClientRect().left; 
            state.cursorScreenY = e.clientY - DOM.viewport.getBoundingClientRect().top; 
            const worldPos = getScreenToWorldPos(e.clientX, e.clientY); 
            state.cursorWorldX = worldPos.x; 
            state.cursorWorldY = worldPos.y; 
            
            if (state.drag.isActive) { doDrag(e); return; } 
            
            if (state.isRotating && (e.buttons & 1)) { 
                state.viewRotation = state.dragStartViewRot + (getMouseAngle(e.clientX, e.clientY) - state.dragStartAngle); 
                if (state.snapToMidline) snapRotation(); 
                DOM.rotationSlider.value = state.viewRotation; 
                render(); 
                return; 
            } 
            
            if (state.isDrawing) { 
                const events = e.getCoalescedEvents ? e.getCoalescedEvents() : [e];
                events.forEach(ev => {
                    const coPos = getScreenToWorldPos(ev.clientX, ev.clientY);
                    state.currentBrushPath.push(coPos);
                });
            } 
            
            if (state.isErasing) { 
                const events = e.getCoalescedEvents ? e.getCoalescedEvents() : [e];
                events.forEach(ev => {
                   const coPos = getScreenToWorldPos(ev.clientX, ev.clientY);
                   const pathToErase = findClosestPath(coPos); 
                   if (pathToErase) state.pathsToErase.add(pathToErase.id); 
                });
            } 
            render(); 
        });

        DOM.viewport.addEventListener('pointerup', e => { 
            if (!e.isPrimary && e.pointerType !== 'pen') return;
            DOM.viewport.releasePointerCapture(e.pointerId); 
            
            if (state.isDrawing) { 
                const layer = getActiveLayer(); 
                if (layer && state.currentBrushPath.length > 0) { 
                    const simplified = simplifyPath(state.currentBrushPath, CONFIG.pathSimplificationThreshold / state.zoom); 
                    layer.paths.push(new Path(simplified)); 
                    saveHistory(); 
                } 
            } 
            
            if (state.isErasing) { 
                const layer = getActiveLayer(); 
                if (layer && state.pathsToErase.size > 0) { 
                    layer.paths = layer.paths.filter(p => !state.pathsToErase.has(p.id)); 
                    saveHistory(); 
                } 
            } 
            
            state.isDrawing = false; 
            state.isErasing = false; 
            state.drag.isActive = false; 
            state.currentBrushPath = []; 
            state.pathsToErase.clear(); 
            render(); 
        });

        DOM.viewport.addEventListener('pointerleave', () => { state.isCursorInCanvas = false; state.isDrawing = false; state.isErasing = false; state.drag.isActive = false; state.currentBrushPath = []; state.pathsToErase.clear(); render(); });
        DOM.viewport.addEventListener('pointerenter', () => { state.isCursorInCanvas = true; });
        function startDrag(e) { state.drag.isActive = true; state.drag.startX = e.clientX; state.drag.startY = e.clientY; state.drag.startPanX = state.panX; state.drag.startPanY = state.panY; }
        function doDrag(e) { if (!state.drag.isActive) return; state.panX = state.drag.startPanX + (e.clientX - state.drag.startX); state.panY = state.drag.startPanY + (e.clientY - state.drag.startY); render(); }
        DOM.viewport.addEventListener('wheel', e => { e.preventDefault(); if (e.shiftKey) { state.viewRotation += (e.deltaY > 0 ? -5 : 5); if (state.snapToMidline) snapRotation(); DOM.rotationSlider.value = state.viewRotation; } else { const rect = DOM.mainCanvas.getBoundingClientRect(); const mx = e.clientX - rect.left, my = e.clientY - rect.top; const zoomFactor = 1.1; let newZoom = state.zoom * (e.deltaY < 0 ? zoomFactor : 1 / zoomFactor); newZoom = Math.max(0.1, Math.min(newZoom, 10)); const offsetX = (mx - state.panX), offsetY = (my - state.panY); state.panX = mx - (offsetX * (newZoom / state.zoom)); state.panY = my - (offsetY * (newZoom / state.zoom)); state.zoom = newZoom; } render(); }, { passive: false });
        
        window.addEventListener('keydown', e => { 
            if (e.target.matches('input')) return; 
            if (e.ctrlKey || e.metaKey) { if (e.key.toLowerCase() === 'z' && e.shiftKey) { e.preventDefault(); redo(); } else if (e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); } if (e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); } if (e.key === '0') { e.preventDefault(); centerView(); } return; } 
            if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') { e.preventDefault(); const direction = e.code === 'ArrowLeft' ? 1 : -1; state.viewRotation += direction * (360 / state.sliceCount); state.viewRotation = (state.viewRotation % 360 + 360) % 360; if (state.isDrawing) state.currentBrushPath.push({ x: state.cursorWorldX, y: state.cursorWorldY }); if (state.snapToMidline) snapRotation(); DOM.rotationSlider.value = state.viewRotation; render(); } 
            if(e.key === '[' || e.key === ']') { const layer = getActiveLayer(); if(layer) { const change = e.key === '[' ? -1 : 1; const newWidth = Math.max(1, Math.min(100, parseInt(layer.strokeWidth) + change)); changeActiveLayerProperty('strokeWidth', newWidth); } } 
            if (e.code === 'Space' && !e.repeat) { e.preventDefault(); state.isPanning = true; DOM.viewport.classList.add('panning'); state.isRotating = false; DOM.viewport.classList.remove('rotating'); } 
            if (e.code === 'KeyR' && !e.repeat) { if (!state.isPanning) { state.isRotating = true; DOM.viewport.classList.add('rotating'); } } 
            
            // æŒ‰é”®åˆ‡æ¢å·¥å…·çš„é€»è¾‘
            if (e.code === 'KeyB') { 
                if (!state.isPanning) { 
                    state.currentTool = 'brush'; 
                    DOM.viewport.classList.remove('erasing'); 
                    updateUI(); 
                    render(); // ç«‹å³åˆ·æ–°
                } 
            } 
            if (e.code === 'KeyE') { 
                if (!state.isPanning) { 
                    state.currentTool = 'eraser'; 
                    DOM.viewport.classList.add('erasing'); 
                    updateUI(); 
                    render(); // ç«‹å³åˆ·æ–°
                } 
            } 
        });
        window.addEventListener('keyup', e => { if (e.code === 'Space') { state.isPanning = false; DOM.viewport.classList.remove('panning'); resetInteractionState(); render(); } if (e.code === 'KeyR') { if (!state.isPanning) { state.isRotating = false; DOM.viewport.classList.remove('rotating'); if (state.snapToMidline) { snapRotation(); render(); } } } });
        window.addEventListener('blur', () => { state.isPanning = false; DOM.viewport.classList.remove('panning', 'rotating'); resetInteractionState(); });
        window.addEventListener('beforeunload', (e) => { if (state.hasUnsavedChanges) { e.preventDefault(); e.returnValue = ''; } });

        DOM.projectNameInput.onchange = e => { state.projectName = e.target.value.trim() || 'æœªå‘½åé¡¹ç›®'; setUnsaved(true); updateUI(); };
        DOM.addLayerBtn.onclick = () => addLayer();
        DOM.delLayerBtn.onclick = deleteLayer;
        DOM.copyLayerBtn.onclick = duplicateLayer;
        DOM.clearLayerBtn.onclick = clearLayer;
        DOM.undoBtn.onclick = undo;
        DOM.redoBtn.onclick = redo;
        DOM.resetViewBtn.onclick = centerView;
        DOM.currentLayerInput.onchange = e => changeActiveLayerProperty('name', e.target.value);
        DOM.layerColorInput.oninput = e => changeActiveLayerProperty('color', e.target.value);
        DOM.brushSize.oninput = e => { const layer = getActiveLayer(); if (layer) { layer.strokeWidth = e.target.value; updateUI(); render(); } };
        DOM.brushSize.onchange = () => saveHistory();
        DOM.layerOpacity.oninput = e => { const layer = getActiveLayer(); if (layer) { layer.opacity = parseFloat(e.target.value); updateUI(); render(); } };
        DOM.layerOpacity.onchange = () => saveHistory();
        DOM.backgroundColorInput.oninput = e => { state.backgroundColor = e.target.value; updateUI(); render(); };
        
        // æ ¸å¿ƒä¿®å¤ï¼šç‚¹å‡»å·¥å…·æŒ‰é’®æ—¶ç«‹å³è°ƒç”¨ render() ä»¥æ›´æ–°å…‰æ ‡
        DOM.modeFillBtn.onclick = () => { if (!state.isPanning) { state.currentTool = 'brush'; DOM.viewport.classList.remove('erasing'); changeActiveLayerProperty('mode', 'fill'); render(); } };
        DOM.modeStrokeBtn.onclick = () => { if (!state.isPanning) { state.currentTool = 'brush'; DOM.viewport.classList.remove('erasing'); changeActiveLayerProperty('mode', 'stroke'); render(); } };
        DOM.toolEraserBtn.onclick = () => { if (!state.isPanning) { state.currentTool = 'eraser'; DOM.viewport.classList.add('erasing'); updateUI(); render(); } };
        
        DOM.onionToggle.onchange = e => { state.onionSkins.enabled = e.target.checked; updateUI(); render(); };
        DOM.onionBeforeToggle.onchange = e => { state.onionSkins.showBefore = e.target.checked; updateUI(); render(); };
        DOM.onionAfterToggle.onchange = e => { state.onionSkins.showAfter = e.target.checked; updateUI(); render(); };
        DOM.onionOpacity.oninput = e => { state.onionSkins.opacity = parseFloat(e.target.value); updateUI(); render(); };
        DOM.snapToggle.onchange = e => { state.snapToMidline = e.target.checked; if (state.snapToMidline) { snapRotation(); render(); } };
        DOM.sliceCount.onchange = e => { state.sliceCount = parseInt(e.target.value); render(); };
        DOM.rotationSlider.oninput = e => { state.viewRotation = parseFloat(e.target.value); render(); };
        DOM.rotationSlider.onchange = () => { if (state.snapToMidline) { snapRotation(); render(); } };
        DOM.resetAllBtn.onclick = () => { if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰å†…å®¹å—ï¼Ÿ')) { state.layers = []; state.projectName = 'æœªå‘½åé¡¹ç›®'; state.backgroundColor = '#ffffff'; addLayer('å›¾å±‚ 1'); state.rotDirection = 1; state.onionSkins.opacity = 0.5; centerView(); updateUI(); saveHistory(); setUnsaved(false); } };
        DOM.fpsRange.oninput = e => { state.fps = parseInt(e.target.value); DOM.fpsVal.textContent = state.fps; };
        DOM.rotateDirBtn.onclick = function() { state.rotDirection *= -1; this.textContent = state.rotDirection === 1 ? 'â†º åå‘' : 'â†» æ­£å‘'; this.classList.toggle('active', state.rotDirection === -1); };
        DOM.playbackModeBtn.onclick = function() { state.playbackMode = state.playbackMode === 'slice' ? 'uniform' : 'slice'; this.textContent = state.playbackMode === 'slice' ? 'é€æ ¼æ¨¡å¼' : 'åŒ€é€Ÿæ¨¡å¼'; };
        DOM.playBtn.onclick = () => { state.isPlaying = !state.isPlaying; DOM.playBtn.textContent = state.isPlaying ? 'â–  åœæ­¢' : 'â–¶ æ’­æ”¾'; DOM.playBtn.classList.toggle('active', state.isPlaying); DOM.playBtn.style.background = state.isPlaying ? 'var(--danger-color)' : ''; if (!state.isPlaying) { state.animRotation = 0; render(); } };
        DOM.onionLayerBtn.onclick = () => { state.onionOnTop = !state.onionOnTop; updateUI(); render(); };

        // å¼¹çª—é€»è¾‘
        DOM.closeModalBtn.onclick = () => { DOM.welcomeModal.style.display = 'none'; };
        DOM.welcomeModal.onclick = (e) => { if (e.target === DOM.welcomeModal) { DOM.welcomeModal.style.display = 'none'; } };

        DOM.exportJsonBtn.onclick = async () => {
            const originalButtonText = DOM.exportJsonBtn.textContent;
            DOM.exportJsonBtn.textContent = 'æ­£åœ¨æ‰“åŒ…...';
            DOM.exportJsonBtn.disabled = true;
            try {
                const unsafeName = state.projectName || 'æœªå‘½åé¡¹ç›®';
                const safeFilename = unsafeName.replace(/[\\/:*?"<>|]/g, '_').trim() || `phenaki_project_${Date.now()}`;
                const dataToExport = { version: '12.0', state: state };
                const jsonString = JSON.stringify(dataToExport, null, 2);
                const pngDataUrl = DOM.mainCanvas.toDataURL('image/png');
                const pngBlob = dataURLtoBlob(pngDataUrl);
                const zip = new JSZip();
                zip.file(`${safeFilename}.json`, jsonString);
                zip.file(`${safeFilename}.png`, pngBlob);
                const zipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 9 } });
                triggerDownload(zipBlob, `${safeFilename}.zip`);
                setUnsaved(false);
            } catch (error) { console.error("å¯¼å‡º ZIP å¤±è´¥:", error); alert("å¯¼å‡ºå¤±è´¥ï¼Œè¯·æ‰“å¼€å¼€å‘è€…æ§åˆ¶å°æŸ¥çœ‹é”™è¯¯ä¿¡æ¯ã€‚"); } finally { DOM.exportJsonBtn.textContent = originalButtonText; DOM.exportJsonBtn.disabled = false; }
        };
        DOM.importJsonInput.onchange = async (e) => {
            if (!e.target.files.length) return;
            const file = e.target.files[0];
            e.target.value = '';
            if (file.name.endsWith('.zip')) {
                try {
                    const zip = await JSZip.loadAsync(file);
                    const jsonFileKey = Object.keys(zip.files).find(name => name.endsWith('.json'));
                    if (!jsonFileKey) { alert('å¯¼å…¥å¤±è´¥: ZIPå‹ç¼©åŒ…ä¸­æœªæ‰¾åˆ° .json é¡¹ç›®æ–‡ä»¶ã€‚'); return; }
                    const jsonString = await zip.files[jsonFileKey].async('string');
                    loadProjectData(jsonString, file.name);
                } catch (err) { alert('å¯¼å…¥å¤±è´¥: æ— æ³•è¯»å–æˆ–è§£å‹ ZIP æ–‡ä»¶ã€‚\n' + err.message); console.error(err); }
            } else if (file.name.endsWith('.json')) {
                const reader = new FileReader();
                reader.onload = () => { loadProjectData(reader.result, file.name); };
                reader.onerror = () => { alert('å¯¼å…¥å¤±è´¥: æ— æ³•è¯»å– JSON æ–‡ä»¶ã€‚'); };
                reader.readAsText(file);
            } else { alert('è¯·é€‰æ‹©ä¸€ä¸ª .json æˆ– .zip æ–‡ä»¶ã€‚'); }
        };
    }

    function getScreenToWorldPos(screenX, screenY) {
        const rect = DOM.viewport.getBoundingClientRect();
        const viewX = screenX - rect.left; const viewY = screenY - rect.top;
        const worldX = (viewX - state.panX) / state.zoom; const worldY = (viewY - state.panY) / state.zoom;
        const cx = CONFIG.baseSize / 2, cy = CONFIG.baseSize / 2;
        const dx = worldX - cx, dy = worldY - cy;
        const dynamicRotation = state.isPlaying ? state.animRotation : 0;
        const rad = -(state.viewRotation + dynamicRotation) * Math.PI / 180;
        const finalX = dx * Math.cos(rad) - dy * Math.sin(rad) + cx;
        const finalY = dx * Math.sin(rad) + dy * Math.cos(rad) + cy;
        return { x: finalX, y: finalY };
    }

        function getMouseAngle(clientX, clientY) { const rect = DOM.mainCanvas.getBoundingClientRect(); const z = state.zoom || 1; const screenCx = rect.left + state.panX + (CONFIG.baseSize/2 * z); const screenCy = rect.top + state.panY + (CONFIG.baseSize/2 * z); return Math.atan2(clientY - screenCy, clientX - screenCx) * 180 / Math.PI; }
        function resizeCanvas() { DOM.mainCanvas.width = DOM.viewport.clientWidth * state.dpr; DOM.mainCanvas.height = DOM.viewport.clientHeight * state.dpr; render(); }
        // ====== iPad/å¹³æ¿ æ‰‹åŠ¿é€‚é…ï¼šProcreateåŒæ¬¾ å¹³ç§»/ç¼©æ”¾/æ—‹è½¬ (æ–°å¢ï¼Œç²˜è´´åˆ°JSæœ«å°¾) ======
    let touchPoints = []; // å­˜å‚¨åŒæŒ‡åæ ‡
    let lastScale = 1;    // ä¸Šä¸€æ¬¡ç¼©æ”¾æ¯”ä¾‹
    let lastAngle = 0;    // ä¸Šä¸€æ¬¡æ—‹è½¬è§’åº¦
    const canvas = document.getElementById('canvas'); // ä½ çš„ç”»å¸ƒIDï¼Œä¸ç”¨æ”¹ï¼

    // è§¦æ‘¸å¼€å§‹ï¼šå•æŒ‡/åŒæŒ‡æŒ‰ä¸‹
    canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); // ç¦æ­¢ç³»ç»Ÿé»˜è®¤è¡Œä¸º
    touchPoints = Array.from(e.touches).map(t => ({ x: t.clientX, y: t.clientY }));
    lastScale = state.scale; // è®°å½•å½“å‰ç¼©æ”¾æ¯”ä¾‹
    lastAngle = state.rotation; // è®°å½•å½“å‰æ—‹è½¬è§’åº¦
    });

    // è§¦æ‘¸ç§»åŠ¨ï¼šæ ¸å¿ƒæ‰‹åŠ¿é€»è¾‘ï¼ˆå•æŒ‡å¹³ç§»ï¼ŒåŒæŒ‡ç¼©æ”¾+æ—‹è½¬ï¼‰
    canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const touches = Array.from(e.touches).map(t => ({ x: t.clientX, y: t.clientY }));
    
    // âœ… å•æŒ‡è§¦æ‘¸ = å¹³ç§»ç”»å¸ƒ (ProcreateåŒæ¬¾ï¼šæŒ‰ä½ç”»å¸ƒæ‹–åŠ¨)
    if (touches.length === 1) {
        if (touchPoints.length === 1) {
        const dx = touches[0].x - touchPoints[0].x;
        const dy = touches[0].y - touchPoints[0].y;
        state.offsetX += dx;
        state.offsetY += dy;
        }
        touchPoints = touches;
    }

    // âœ… åŒæŒ‡è§¦æ‘¸ = ç¼©æ”¾+æ—‹è½¬ç”»å¸ƒ (ProcreateåŒæ¬¾ï¼šæåˆç¼©æ”¾ã€æ—‹è½¬æ‰‹åŠ¿)
    if (touches.length === 2 && touchPoints.length === 2) {
        // è®¡ç®—åŒæŒ‡è·ç¦» = ç¼©æ”¾æ¯”ä¾‹
        const getDistance = (p1, p2) => Math.hypot(p2.x - p1.x, p2.y - p1.y);
        const currDist = getDistance(touches[0], touches[1]);
        const prevDist = getDistance(touchPoints[0], touchPoints[0]);
        const scaleFactor = currDist / (prevDist || 1);
        state.scale = lastScale * scaleFactor;
        state.scale = Math.max(0.2, Math.min(5, state.scale)); // ç¼©æ”¾èŒƒå›´é™åˆ¶ï¼Œé˜²æ­¢è¿‡å¤§è¿‡å°

        // è®¡ç®—åŒæŒ‡è§’åº¦ = ç”»å¸ƒæ—‹è½¬è§’åº¦
        const getAngle = (p1, p2) => Math.atan2(p2.y - p1.y, p2.x - p1.x);
        const currAngle = getAngle(touches[0], touches[1]);
        const prevAngle = getAngle(touchPoints[0], touchPoints[0]);
        const angleDiff = currAngle - prevAngle;
        state.rotation = lastAngle + angleDiff * 180 / Math.PI;
    }
    });

    // è§¦æ‘¸ç»“æŸï¼šæ¸…ç©ºæ‰‹åŠ¿çŠ¶æ€
    canvas.addEventListener('touchend', () => {
    touchPoints = [];
    });
    canvas.addEventListener('touchcancel', () => {
    touchPoints = [];
    });
    function loop(time) {
        if (state.isPlaying) {
            if (!window._lastTime) window._lastTime = time;
            const deltaTime = time - window._lastTime;
            window._lastTime = time;
            if (state.playbackMode === 'slice') {
                if (!window._sliceTime) window._sliceTime = 0;
                window._sliceTime += deltaTime;
                if (window._sliceTime > 1000 / state.fps) {
                    const step = 360 / state.sliceCount;
                    state.animRotation = (state.animRotation - (step * state.rotDirection));
                    window._sliceTime = 0;
                }
            } else {
                const degreesPerSecond = state.fps * 6;
                const rotationThisFrame = degreesPerSecond * (deltaTime / 1000);
                state.animRotation = (state.animRotation - (rotationThisFrame * state.rotDirection));
            }
            render();
        } else { window._lastTime = 0; window._sliceTime = 0; }
        requestAnimationFrame(loop);
    }
    
    function drawGrid(ctx) { 
        const cx = CONFIG.baseSize / 2, cy = CONFIG.baseSize / 2, r = CONFIG.baseSize / 2 - 2; 
        const step = 360 / state.sliceCount; 
        const offset = step / 2; 
        const z = state.zoom || 1; 
        const lw = 1/z; 
        ctx.setLineDash([]); 
        ctx.strokeStyle = 'rgba(0,188,212,0.2)'; 
        ctx.lineWidth = lw; 
        ctx.beginPath(); 
        for (let i = 0; i < state.sliceCount; i++) { 
            const rad = (i * step + offset) * Math.PI / 180; 
            ctx.moveTo(cx, cy); 
            ctx.lineTo(cx + Math.cos(rad)*r, cy + Math.sin(rad)*r); 
        } 
        ctx.stroke(); 
        ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
        ctx.setLineDash([4/z, 4/z]);
        ctx.beginPath();
        for (let i = 0; i < state.sliceCount; i++) {
            const rad = (i * step) * Math.PI / 180;
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx + Math.cos(rad) * r, cy + Math.sin(rad) * r);
        }
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.beginPath(); 
        ctx.strokeStyle = 'rgba(255,50,50,0.5)'; 
        ctx.lineWidth = 2/z; 
        ctx.moveTo(cx, cy); 
        ctx.lineTo(cx, cy - r); 
        ctx.stroke(); 
    }

    function snapRotation() { if (!state.snapToMidline) return; const step = 360 / state.sliceCount; state.viewRotation = Math.round(state.viewRotation / step) * step; state.viewRotation = (state.viewRotation % 360 + 360) % 360; }
    function centerView() { const w = DOM.viewport.clientWidth, h = DOM.viewport.clientHeight; if(!w || !h) return; state.zoom = Math.min(w, h) / CONFIG.baseSize * 0.9; state.panX = (w - CONFIG.baseSize * state.zoom) / 2; state.panY = (h - CONFIG.baseSize * state.zoom) / 2; state.viewRotation = 0; snapRotation(); DOM.rotationSlider.value = 0; render(); }
    
    document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>